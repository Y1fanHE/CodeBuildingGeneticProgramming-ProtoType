from typing import Any, Iterator, Callable, Optional, Sequence, Tuple

from pyrsistent import PVector, PMap, PSet, pvector


class RichVector(PVector):

    def combinations(self, n: int) -> Iterator["RichVector"]:
        ...

    def contains(self, element: Any) -> bool:
        ...

    def count(self, pred: Callable[[Any], bool]) -> int:
        ...

    def distinct(self) -> "RichVector":
        ...

    def drop(self, n: int) -> "RichVector":
        ...

    def drop_right(self, n: int) -> "RichVector":
        ...

    def exists(self, pred: Callable[[Any], bool]) -> bool:
        ...

    def filter(self, pred: Callable[[Any], bool]) -> "RichVector":
        ...

    def filter_not(self, pred: Callable[[Any], bool]) -> "RichVector":
        ...

    def find(self, pred: Callable[[Any], bool]) -> Optional[Any]:
        ...

    def flat_map(self, fn: Callable[[Any], Sequence[Any]]) -> "RichVector":
        ...

    def flatten(self) -> "RichVector":
        ...

    def for_all(self, pred: Callable[[Any], bool]) -> bool:
        ...

    def for_each(self, fn: Callable[[Any], Any]):
        ...

    def group_by(self, fn: Callable[[Any], Any]) -> "RichMap":
        ...

    def grouped(self, size: int) -> "RichMap":
        ...

    def head(self) -> Any:
        ...

    def index_of(self, elem: Any) -> Optional[int]:
        ...

    def index_where(self, pred: Callable[[Any], bool]) -> Optional[int]:
        ...

    def intersect(self, other: Sequence) -> "RichVector":
        ...

    def is_defined_at(self, idx: int) -> bool:
        ...

    def is_empty(self) -> bool:
        ...

    def last(self) -> Any:
        ...

    def last_index_of(self, elem: Any) -> Optional[int]:
        ...

    def last_index_where(self, pred: Callable[[Any], bool]) -> Optional[int]:
        ...

    def length(self) -> int:
        ...

    def max(self) -> Any:
            ...

    def max_by(self, fn: Callable[[Any], Any]) -> Any:
        ...

    def min(self) -> Any:
        ...

    def min_by(self, fn: Callable[[Any], Any]) -> Any:
        ...

    def make_string(self, start: str, sep: str, end: str) -> str:
        ...

    def partition(self, pred: Callable[[Any], bool]) -> Tuple["RichVector", "RichVector"]:
        ...

    def reduce(self, fn: Callable[[Any, Any], Any], init: Optional[Any] = None) -> Any:
        ...

    def reduce_right(self, fn: Callable[[Any, Any], Any], init: Optional[Any] = None) -> Any:
        ...

    def size(self) -> int:
        ...

    def slice(self, start: int, end: int) -> "RichVector":
        ...

    def sliding(self, size: int, step: int) -> Iterator["RichVector"]:
        ...

    def sort_by(self, fn: Callable[[Any], Any]) -> "RichVector":
        ...

    def sorted(self) -> "RichVector":
        ...

    def sort_with(self, fn: Callable[[Any, Any], bool]) -> "RichVector":
        ...

    def tail(self) -> Any:
        ...

    def take(self, n: int) -> "RichVector":
        ...

    def take_right(self, n: int) -> "RichVector":
        ...

    def take_while(self, pred: Callable[[Any], bool]) -> "RichVector":
        ...


class RichMap(PMap):

    ...


class RichSet(PSet):

    ...
